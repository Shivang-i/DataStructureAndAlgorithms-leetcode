//Brute force approch
import java.util.*;

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
       
        // Using a HashSet to avoid duplicate triplets
        HashSet<List<Integer>> set = new HashSet<>();
        
        // Sort the array so triplets are in order (helps with uniqueness)
        Arrays.sort(nums);
        int n = nums.length;

        // Brute force: check every triplet (i, j, k)
        for (int i = 0; i < n - 2; i++) {            // First element
            for (int j = i + 1; j < n - 1; j++) {    // Second element
                for (int k = j + 1; k < n; k++) {    // Third element
                    // If the sum of the triplet is zero
                    if (nums[i] + nums[j] + nums[k] == 0) {
                        // Create the triplet list
                        List<Integer> ans = new ArrayList<>();
                        ans.add(nums[i]);
                        ans.add(nums[j]);
                        ans.add(nums[k]);

                        // Add to set (automatically removes duplicates)
                        set.add(ans);
                    }
                }
            }
        }

        // Convert the set of unique triplets into a list
        List<List<Integer>> result = new ArrayList<>(set);
        return result;
    }
}


//Optimized 2 pointers 

import java.util.*;

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        // If the array has fewer than 3 elements, no triplet can sum to 0
        if (nums.length < 3)
            return new ArrayList<>();

        // Using a HashSet to store unique triplets
        HashSet<List<Integer>> set = new HashSet<>();

        // Sort the array to use the two-pointer approach effectively
        Arrays.sort(nums);
        int n = nums.length;
        int sum = 0;

        // Fix the first element one by one
        for (int i = 0; i < n - 2; i++) {
            int j = i + 1;    // left pointer
            int k = n - 1;    // right pointer

            // Move the two pointers towards each other
            while (j < k) {
                sum = nums[i] + nums[j] + nums[k];

                if (sum == 0) {
                    // Found a valid triplet
                    ArrayList<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[j]);
                    list.add(nums[k]);

                    // Add triplet to the set (automatically removes duplicates)
                    set.add(list);

                    // Move both pointers inward to look for new triplets
                    j++;
                    k--;
                } 
                else if (sum > 0) {
                    // Sum too big, decrease it by moving right pointer left
                    k--;
                } 
                else {
                    // Sum too small, increase it by moving left pointer right
                    j++;
                }
            }
        }

        // Convert the set of unique triplets into a list before returning
        return new ArrayList<>(set);
    }
}
