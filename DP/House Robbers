/*
Objective: 
-----------
This is the classic "House Robber" problem.

Problem statement:
- You are given an array `nums` where each element represents the amount of money in a house.
- You are a robber planning to rob houses along a street.
- The constraint: You cannot rob two adjacent houses (because it would trigger an alarm).
- Goal: Find the maximum amount of money you can rob without alerting the police.

Approach:
----------
We use recursion with memoization (top-down dynamic programming).
At each index (house), we have two choices:
1. **Steal from current house** → add current value + skip the next house (`idx + 2`).
2. **Skip current house** → move to next house (`idx + 1`).
The maximum of these two choices is stored in `dp[idx]` to avoid recomputation.
*/

import java.util.Arrays;

class Solution {
    
    // Recursive helper function to calculate max loot starting from index idx
    public int maxLoot(int arr[], int idx, int[] dp) {
        // Base case: if index goes beyond the array, return 0
        if (idx >= arr.length) return 0;

        // If result is already computed, return it (memoization)
        if (dp[idx] != -1) return dp[idx];

        // Option 1: Rob this house, then skip the next one
        int steal = arr[idx] + maxLoot(arr, idx + 2, dp);

        // Option 2: Skip this house, move to the next one
        int skip = maxLoot(arr, idx + 1, dp);

        // Store the maximum of the two choices in dp array
        return dp[idx] = Math.max(steal, skip);
    }

    // Main function: entry point for solving the problem
    public int rob(int[] nums) {
        // dp array initialized with -1 to mark uncomputed states
        int[] dp = new int[nums.length];
        Arrays.fill(dp, -1);

        // Start from house at index 0
        return maxLoot(nums, 0, dp);
    }
}



//tabulation 


class Solution {
    public int findMaxSum(int arr[]) {
        // Get the total number of elements in the array
        int n = arr.length;

        // If there's only one element, the maximum sum is that element itself
        if (n == 1) {
            return arr[0];
        }

        // Create a dp array to store the maximum sum up to each index
        int dp[] = new int[n];

        // Maximum sum at the first element is the element itself
        dp[0] = arr[0];

        // Maximum sum at the second element is the max of first element or second element
        dp[1] = Math.max(arr[0], arr[1]);

        // Compute the maximum sum for each element starting from the third
        for (int i = 2; i < n; i++) {
            // For each element, you have two choices:
            // 1. Include the current element and add it to dp[i-2] (skip previous element)
            // 2. Exclude the current element and take the maximum sum up to previous element (dp[i-1])
            // Take the maximum of these two choices
            dp[i] = Math.max(arr[i] + dp[i - 2], dp[i - 1]);
        }

        // The maximum sum without adjacent elements is stored in the last index of dp array
        return dp[n - 1];
    }
}
