/*
Objective:
-----------
This is the "Min Cost Climbing Stairs" problem.

Problem statement:
- You are given an integer array `cost` where `cost[i]` is the cost of the i-th step.
- Once you pay the cost at step `i`, you can climb either to step `i+1` or step `i+2`.
- You can start from step 0 or step 1.
- Goal: Find the minimum cost to reach the "top" (just beyond the last step).

Approach:
----------
We use recursion with memoization (top-down DP).
- At each step `idx`, we pay `cost[idx]` and choose the cheaper option:
    1. Move to `idx + 1`
    2. Move to `idx + 2`
- The recursive relation:
    dp[idx] = cost[idx] + min(helper(idx+1), helper(idx+2))
- Base case: If `idx >= cost.length`, return 0 (already at or beyond the top).
- Since we can start from step 0 or step 1, answer = min(helper(0), helper(1)).
*/

import java.util.Arrays;

class Solution {

    // Recursive helper function with memoization
    static int helper(int[] cost, int idx, int[] dp) {
        // Base case: Reached or passed the top, no extra cost
        if (idx >= cost.length) {
            return 0;
        }

        // If already computed, return stored result
        if (dp[idx] != -1) return dp[idx];

        // Choice: pay cost at current step and move either +1 or +2
        return dp[idx] = cost[idx] + Math.min(helper(cost, idx + 1, dp), 
                                              helper(cost, idx + 2, dp));
    }

    // Main function to calculate minimum cost to reach the top
    static int minCostClimbingStairs(int[] cost) {
        int[] dp = new int[cost.length];
        Arrays.fill(dp, -1);

        // Can start from step 0 or step 1
        return Math.min(helper(cost, 0, dp), helper(cost, 1, dp));
    }
}


//Approch 2

class Solution {
    static int minCostClimbingStairs(int[] cost) {
        // Get the total number of steps
        int n = cost.length;

        // Create a dp array to store the minimum cost to reach each step
        int dp[] = new int[n];

        // The minimum cost to reach step 0 is just the cost of step 0
        dp[0] = cost[0];

        // The minimum cost to reach step 1 is just the cost of step 1
        dp[1] = cost[1];

        // Compute the minimum cost for each step starting from step 2
        for (int i = 2; i < n; i++) {
            // To reach step i, we can come either from step (i-1) or (i-2)
            // We take the minimum cost of these two options and add the cost of current step
            dp[i] = cost[i] + Math.min(dp[i - 1], dp[i - 2]);
        }

        // We can reach the top either from the last step or the second last step
        // Return the minimum cost to reach the top
        return Math.min(dp[n - 1], dp[n - 2]);
    }
}
